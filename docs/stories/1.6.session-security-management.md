# Story 1.6: 會話與安全管理

**Status**: Draft

---

## Story

**As a** 重視帳號安全的用戶,
**I want** 能夠管理我的登入會話和查看帳號活動,
**so that** 確保我的帳號安全性

---

## Acceptance Criteria

1. 用戶可以查看目前活躍的登入會話（裝置、位置、時間）
2. 用戶可以強制登出特定裝置的會話
3. 系統記錄重要的帳號活動（登入、檔案變更、密碼變更）
4. 用戶可以查看個人的帳號活動記錄
5. 異常登入活動會有安全提醒

---

## Dev Notes

### Previous Story Insights (Story 1.1-1.5)
- ✅ JWT 認證系統已完整實作於 `backend/app/core/security.py`
  - `create_access_token()` - 建立 JWT token with 可配置過期時間
  - `decode_access_token()` - 解碼並驗證 JWT token
  - `get_current_user()` - 認證守衛依賴項
  - Token 包含 payload: `{"sub": user_email, "exp": expiration_time}`
  - 支援 remember_me: 30分鐘 vs 7天 token 有效期
  - [Source: backend/app/core/security.py, backend/app/api/endpoints/auth.py]
- ✅ User Model 已包含帳號保護機制欄位：
  - `failed_login_attempts: int` - 登入失敗計數
  - `locked_until: Optional[datetime]` - 帳號鎖定時間
  - `created_at: datetime` - 帳號建立時間
  - `updated_at: datetime` - 最後更新時間
  - [Source: backend/app/models/user.py]
- ✅ 登入失敗保護機制已實作於 `UserService.authenticate()`
  - 5次失敗嘗試後鎖定帳號15分鐘
  - [Source: backend/app/services/user_service.py]
- ✅ 測試基礎設施完善：
  - pytest + TestClient + in-memory SQLite
  - `authenticated_client` fixture 可模擬認證用戶
  - Story 1.5 示範了完整的測試模式（單元測試 + 整合測試）
  - [Source: backend/tests/conftest.py, backend/tests/integration/test_dashboard_api.py]

### Architecture Context: Session Management Strategy

**重要架構決策**：本專案採用 **JWT (Stateless) Token** 認證策略，而非傳統的 Server-Side Session。

[Source: docs/architecture/2-後端架構詳細設計-sqlmodel.md#安全性設計, backend/app/core/security.py]

**當前 JWT 實作特性：**
- Token 儲存於前端 localStorage
- Token payload 包含：`sub` (user email) 和 `exp` (expiration)
- Token 一旦發出即無法主動撤銷（JWT 的固有特性）
- 無伺服器端 Session 儲存

**Story 1.6 的實作策略：**

由於 JWT 的 stateless 特性，要實現「查看活躍會話」和「強制登出」功能，需要在後端引入 **Session Tracking 機制**：

1. **新增 Session 資料表**（`LoginSession`）：
   - 記錄每次登入產生的 token 元數據（不儲存完整 token）
   - 儲存：user_id, session_id (JTI), device_info, ip_address, login_time, last_active_time, is_active
   - 當用戶登入時，建立 Session 記錄
   - 當用戶「強制登出」時，將 Session 標記為 `is_active=False`

2. **JWT Token 增強**（加入 JTI）：
   - 在 `create_access_token()` 中加入 `jti` (JWT ID) claim
   - JTI 作為 Session 的唯一識別碼

3. **Token 驗證增強**：
   - 修改 `get_current_user()` 驗證邏輯，檢查 token 的 JTI 是否在 Session 表中且 `is_active=True`
   - 若 Session 已被撤銷（`is_active=False`），則拒絕請求

4. **Activity Log 資料表**（`ActivityLog`）：
   - 記錄重要帳號活動：login, profile_update, password_change, session_logout 等
   - 儲存：user_id, activity_type, description, ip_address, timestamp, metadata (JSON)

**注意事項：**
- 此方法在 JWT 基礎上增加了 Session 追蹤，既保留 JWT 的優勢（減少資料庫查詢），又實現了會話管理功能
- 每次 API 請求仍需查詢 Session 表驗證 JTI，對效能有輕微影響（可用 Redis 快取優化，但本 Epic 不實作）
- 此設計符合 PRD NFR1.5（安全防護）的要求

### Data Models

#### LoginSession Model (需要新建)
[Source: docs/architecture/2-後端架構詳細設計-sqlmodel.md#資料模型與-api-schema]

```python
# backend/app/models/session.py (新建檔案)
from typing import Optional
from datetime import datetime
from sqlmodel import Field, SQLModel, Relationship

class LoginSession(SQLModel, table=True):
    """用戶登入會話記錄"""
    __tablename__ = "loginsession"
    
    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: int = Field(foreign_key="user.id", index=True)
    session_id: str = Field(unique=True, index=True, max_length=255)  # JWT JTI
    
    # 裝置與位置資訊
    device_info: Optional[str] = Field(default=None, max_length=500)  # User-Agent
    ip_address: Optional[str] = Field(default=None, max_length=45)    # IPv4/IPv6
    
    # 時間戳
    login_time: datetime = Field(default_factory=datetime.utcnow)
    last_active_time: datetime = Field(default_factory=datetime.utcnow)
    expires_at: datetime  # Token 過期時間
    
    # 會話狀態
    is_active: bool = Field(default=True, index=True)
    
    # Relationships
    user: "User" = Relationship(back_populates="sessions")

class SessionRead(SQLModel):
    """會話資訊 API 回應"""
    id: int
    session_id: str
    device_info: Optional[str]
    ip_address: Optional[str]
    login_time: datetime
    last_active_time: datetime
    expires_at: datetime
    is_active: bool
```

#### ActivityLog Model (需要新建)
[Source: docs/architecture/2-後端架構詳細設計-sqlmodel.md#資料模型與-api-schema]

```python
# backend/app/models/activity_log.py (新建檔案)
from typing import Optional, Literal
from datetime import datetime
from sqlmodel import Field, SQLModel, Column, JSON

ActivityType = Literal[
    "login", 
    "logout", 
    "profile_update", 
    "password_change", 
    "avatar_upload",
    "google_link",
    "google_unlink",
    "session_revoked"
]

class ActivityLog(SQLModel, table=True):
    """用戶活動記錄"""
    __tablename__ = "activitylog"
    
    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: int = Field(foreign_key="user.id", index=True)
    
    # 活動資訊
    activity_type: str = Field(max_length=50, index=True)  # ActivityType
    description: str = Field(max_length=500)
    
    # 請求資訊
    ip_address: Optional[str] = Field(default=None, max_length=45)
    user_agent: Optional[str] = Field(default=None, max_length=500)
    
    # 時間戳
    timestamp: datetime = Field(default_factory=datetime.utcnow, index=True)
    
    # 額外元數據（JSON 格式）
    metadata: Optional[dict] = Field(default=None, sa_column=Column(JSON))
    
    # Relationships
    user: "User" = Relationship(back_populates="activity_logs")

class ActivityLogRead(SQLModel):
    """活動記錄 API 回應"""
    id: int
    activity_type: str
    description: str
    ip_address: Optional[str]
    timestamp: datetime
    metadata: Optional[dict]
```

#### User Model 擴展
[Source: backend/app/models/user.py]

需要在 `User` model 中新增 Relationships：

```python
class User(UserBase, table=True):
    # ... existing fields ...
    
    # 新增 Relationships
    sessions: List["LoginSession"] = Relationship(back_populates="user")
    activity_logs: List["ActivityLog"] = Relationship(back_populates="user")
```

### API Specifications

#### API 端點設計
[Source: docs/architecture/2-後端架構詳細設計-sqlmodel.md#RESTful-API-設計範例]

**需要新增的端點：**

1. **GET /api/users/me/sessions** - 獲取用戶所有會話
   - 認證：Required (JWT)
   - 回應：`List[SessionRead]`
   - 僅返回活躍會話（`is_active=True`）和尚未過期的會話
   - 按 `last_active_time` 降序排列（最近活動的在前）

2. **DELETE /api/users/me/sessions/{session_id}** - 撤銷特定會話
   - 認證：Required (JWT)
   - 路徑參數：`session_id` (string, JWT JTI)
   - 行為：將指定 Session 的 `is_active` 設為 `False`
   - 記錄 ActivityLog: `session_revoked`
   - 注意：用戶只能撤銷自己的會話，不能撤銷其他用戶的會話

3. **DELETE /api/users/me/sessions** - 撤銷所有其他會話（保留當前）
   - 認證：Required (JWT)
   - 行為：將當前用戶的所有 Session（除了當前 JTI）設為 `is_active=False`
   - 記錄 ActivityLog: `logout`（批次）
   - 用途：「登出所有裝置」功能

4. **GET /api/users/me/activities** - 獲取用戶活動記錄
   - 認證：Required (JWT)
   - 查詢參數：
     - `limit` (int, default=50, max=100) - 返回記錄數
     - `offset` (int, default=0) - 分頁偏移量
     - `activity_type` (optional string) - 過濾特定活動類型
   - 回應：`List[ActivityLogRead]`
   - 按 `timestamp` 降序排列（最新的在前）

**需要修改的端點：**

5. **POST /api/auth/login** - 登入端點增強
   - 當前：返回 JWT token
   - 增強：
     - 在 token payload 中加入 `jti` (JWT ID)
     - 建立 `LoginSession` 記錄（儲存 JTI, device_info, ip_address）
     - 記錄 `ActivityLog`: `login`
     - 從 Request headers 提取 `User-Agent` 和 `X-Forwarded-For` (或 `request.client.host`)

6. **POST /api/auth/google/login** - Google 登入增強
   - 同樣的增強邏輯：建立 Session 記錄 + Activity Log

### File Locations and Project Structure
[Source: docs/architecture/2-後端架構詳細設計-sqlmodel.md#FastAPI-專案結構]

**需要創建的檔案：**

1. **Models**：
   - 新建：`backend/app/models/session.py` - LoginSession 和 SessionRead
   - 新建：`backend/app/models/activity_log.py` - ActivityLog 和 ActivityLogRead

2. **Services**：
   - 新建：`backend/app/services/session_service.py` - 會話管理邏輯
     - `create_session()` - 建立新會話記錄
     - `get_user_sessions()` - 獲取用戶所有活躍會話
     - `revoke_session()` - 撤銷特定會話
     - `revoke_other_sessions()` - 撤銷所有其他會話
     - `cleanup_expired_sessions()` - 清理過期會話（定期任務用）
   - 新建：`backend/app/services/activity_service.py` - 活動記錄邏輯
     - `log_activity()` - 記錄活動
     - `get_user_activities()` - 獲取用戶活動記錄

3. **API Endpoints**：
   - 新建：`backend/app/api/endpoints/sessions.py` - 會話管理端點
   - 修改：`backend/app/api/endpoints/auth.py` - 增強登入端點

4. **Core Security**：
   - 修改：`backend/app/core/security.py`
     - `create_access_token()` - 加入 `jti` 參數和 claim
     - `get_current_user()` - 增加 Session 驗證邏輯（檢查 JTI 是否有效）

5. **Database Migration**：
   - 新建：`backend/alembic/versions/{hash}_add_session_and_activity_tables.py`
   - 創建指令：`alembic revision --autogenerate -m "add session and activity tables"`

**專案結構參考：**
```
/backend/
├── app/
│   ├── api/
│   │   └── endpoints/
│   │       ├── auth.py            # 修改：增強登入邏輯
│   │       └── sessions.py        # 新建：會話管理端點
│   ├── core/
│   │   └── security.py            # 修改：JWT 加入 JTI 和 Session 驗證
│   ├── models/
│   │   ├── session.py             # 新建：LoginSession model
│   │   ├── activity_log.py        # 新建：ActivityLog model
│   │   └── user.py                # 修改：新增 Relationships
│   └── services/
│       ├── session_service.py     # 新建：Session service
│       └── activity_service.py    # 新建：Activity service
```

### Technical Constraints and Implementation Notes

#### JWT JTI (JWT ID) 實作

**JTI 生成策略**：
- 使用 `uuid.uuid4()` 生成唯一識別碼
- 格式：`str(uuid.uuid4())` (例如：`"a8f5f167-0e5b-4c59-a4e7-5f6c3a9d8b2e"`)
- 在 `create_access_token()` 中加入：
  ```python
  import uuid
  
  def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> tuple[str, str]:
      to_encode = data.copy()
      
      # 生成 JTI
      jti = str(uuid.uuid4())
      to_encode["jti"] = jti
      
      # 設定過期時間
      if expires_delta:
          expire = datetime.utcnow() + expires_delta
      else:
          expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
      
      to_encode["exp"] = expire
      
      encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
      return encoded_jwt, jti  # 返回 token 和 jti
  ```

#### Session 驗證增強

**修改 `get_current_user()` 函數**：
```python
def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security_scheme),
    session: Session = Depends(get_session)
):
    token = credentials.credentials
    payload = decode_access_token(token)
    
    if not payload:
        raise HTTPException(status_code=401, detail="Invalid or expired token")
    
    email = payload.get("sub")
    jti = payload.get("jti")
    
    if not email or not jti:
        raise HTTPException(status_code=401, detail="Invalid token payload")
    
    # 驗證 Session 是否有效
    from app.services.session_service import SessionService
    if not SessionService.is_session_valid(session, jti):
        raise HTTPException(status_code=401, detail="Session has been revoked")
    
    # 更新 Session 的 last_active_time
    SessionService.update_last_active(session, jti)
    
    # 返回 payload（包含 email 和 jti）
    return payload
```

**注意事項：**
- 這會增加每個 API 請求的資料庫查詢（Session 表）
- 對效能有輕微影響，但在 Epic 1 階段可接受
- 未來可用 Redis 快取 Session 狀態來優化（Epic 4 或之後）

#### 請求元數據提取

**從 FastAPI Request 提取資訊**：
```python
from fastapi import Request

def extract_request_metadata(request: Request) -> dict:
    """提取請求元數據（裝置資訊、IP）"""
    user_agent = request.headers.get("User-Agent", "Unknown")
    
    # 取得真實 IP（考慮 Proxy/Load Balancer）
    ip_address = (
        request.headers.get("X-Forwarded-For", "").split(",")[0].strip()
        or request.headers.get("X-Real-IP", "")
        or (request.client.host if request.client else "Unknown")
    )
    
    return {
        "user_agent": user_agent,
        "ip_address": ip_address
    }
```

#### 異常登入偵測（AC 5）

**簡化實作策略**（Epic 1 階段）：

本故事專注於**記錄機制**，為未來的異常偵測奠定基礎：

1. **記錄關鍵資訊**：
   - 每次登入記錄 IP 和裝置資訊
   - 儲存於 LoginSession 和 ActivityLog

2. **預留擴展空間**：
   - ActivityLog 的 `metadata` 欄位（JSON）可儲存額外資訊
   - 例如：首次登入的地理位置、常用裝置列表等

3. **未來擴展**（Epic 4 或之後）：
   - 分析歷史登入模式（常用 IP、裝置）
   - 偵測異常：新裝置、新地理位置、異常時間登入
   - 發送安全提醒（Email/通知）

**本故事的實作重點**：
- ✅ 記錄完整的登入元數據
- ✅ 提供 API 讓用戶查看登入歷史
- ❌ **不實作**自動異常偵測（留待 Epic 4）

### Security Considerations
[Source: docs/prd/3-非功能需求.md#NFR1.5, docs/architecture/2-後端架構詳細設計-sqlmodel.md#安全性設計]

1. **Session 撤銷權限控制**：
   - 用戶只能查看和撤銷自己的會話
   - 在 Service 層驗證 `session.user_id == current_user_id`

2. **敏感資訊保護**：
   - Session 表不儲存完整 JWT token（僅儲存 JTI）
   - ActivityLog 不記錄密碼或 token（僅記錄事件類型和描述）

3. **資料隔離**：
   - 所有查詢必須過濾 `user_id`，防止資料洩漏

4. **效能考量**：
   - Session 表的 `session_id` (JTI) 和 `user_id` 加索引
   - ActivityLog 的 `user_id` 和 `timestamp` 加索引
   - 定期清理過期的 Session 記錄（可用 Cron job，但本故事不實作）

5. **Rate Limiting**：
   - 撤銷會話的端點應加 Rate Limiting（防止濫用）
   - 參考 NFR1.5，但 Epic 1 階段可暫不實作（標記 TODO）

### Testing Requirements

⚠️ **本故事必須包含測試**（延續 Story 1.4-1.5 的測試文化）

#### 單元測試 (必須)

1. **SessionService 測試** (`backend/tests/unit/test_session_service.py`)：
   - ✓ 建立新會話記錄
   - ✓ 獲取用戶所有活躍會話
   - ✓ 撤銷特定會話
   - ✓ 撤銷所有其他會話（保留當前）
   - ✓ 驗證 Session 是否有效
   - ✓ 更新 last_active_time

2. **ActivityService 測試** (`backend/tests/unit/test_activity_service.py`)：
   - ✓ 記錄活動
   - ✓ 獲取用戶活動記錄（分頁）
   - ✓ 過濾特定活動類型

3. **JWT JTI 測試** (`backend/tests/unit/test_security_jti.py`)：
   - ✓ `create_access_token()` 包含 JTI claim
   - ✓ JTI 為有效 UUID 格式
   - ✓ `decode_access_token()` 正確提取 JTI

#### 整合測試 (必須)

1. **Session API 測試** (`backend/tests/integration/test_sessions_api.py`)：
   - ✓ GET /api/users/me/sessions - 認證用戶獲取會話列表
   - ✗ GET /api/users/me/sessions - 未認證用戶（應返回 401）
   - ✓ DELETE /api/users/me/sessions/{session_id} - 撤銷特定會話
   - ✗ DELETE /api/users/me/sessions/{session_id} - 嘗試撤銷其他用戶的會話（應返回 404 或 403）
   - ✓ DELETE /api/users/me/sessions - 撤銷所有其他會話
   - ✓ 驗證撤銷後的 token 無法使用（401）

2. **Activity API 測試** (`backend/tests/integration/test_activities_api.py`)：
   - ✓ GET /api/users/me/activities - 獲取活動記錄
   - ✗ GET /api/users/me/activities - 未認證用戶（應返回 401）
   - ✓ 驗證分頁參數（limit, offset）
   - ✓ 驗證過濾參數（activity_type）
   - ✓ 驗證活動記錄按時間降序排列

3. **Enhanced Login 測試** (`backend/tests/integration/test_auth_enhanced.py`)：
   - ✓ POST /api/auth/login - 驗證登入後建立 Session 記錄
   - ✓ 驗證登入記錄 ActivityLog
   - ✓ 驗證 token 包含 JTI
   - ✓ 驗證多次登入建立多個 Session
   - ✓ 驗證 remember_me 影響 Session 的 expires_at

#### 測試檔案位置
[Source: docs/architecture/2-後端架構詳細設計-sqlmodel.md#FastAPI-專案結構]

- `backend/tests/unit/test_session_service.py` (新建)
- `backend/tests/unit/test_activity_service.py` (新建)
- `backend/tests/unit/test_security_jti.py` (新建)
- `backend/tests/integration/test_sessions_api.py` (新建)
- `backend/tests/integration/test_activities_api.py` (新建)
- `backend/tests/integration/test_auth_enhanced.py` (新建)

#### 測試框架
- 使用 `pytest` 進行測試
- 使用 `pytest-cov` 測量覆蓋率
- 目標覆蓋率：80% (依據 NFR1.6)
- 參考 Story 1.5 的測試模式和 `conftest.py` 配置

#### 測試輔助 Fixtures (需要新增)

**在 `backend/tests/conftest.py` 新增**：
```python
@pytest.fixture
def authenticated_user_with_jti(client: TestClient, session: Session):
    """建立一個認證用戶並返回 user, token, jti"""
    # 建立測試用戶
    user_data = UserCreate(
        email="test@example.com",
        display_name="Test User",
        password="TestPass123"
    )
    user = UserService.create(session, user_data)
    
    # 建立 token（包含 JTI）
    token, jti = create_access_token({"sub": user.email})
    
    # 建立 Session 記錄
    session_record = LoginSession(
        user_id=user.id,
        session_id=jti,
        device_info="pytest-client",
        ip_address="127.0.0.1",
        expires_at=datetime.utcnow() + timedelta(minutes=30)
    )
    session.add(session_record)
    session.commit()
    
    return user, token, jti
```

---

## Tasks / Subtasks

### Task 1: 資料庫 Schema - LoginSession 和 ActivityLog (AC: 1, 3)
- [ ] 1.1 創建 `backend/app/models/session.py`
  - 實作 `LoginSession` model（table=True）
  - 實作 `SessionRead` schema（用於 API 回應）
- [ ] 1.2 創建 `backend/app/models/activity_log.py`
  - 實作 `ActivityLog` model（table=True）
  - 實作 `ActivityLogRead` schema（用於 API 回應）
  - 定義 `ActivityType` Literal 類型
- [ ] 1.3 修改 `backend/app/models/user.py`
  - 新增 `sessions` Relationship
  - 新增 `activity_logs` Relationship
- [ ] 1.4 創建 Alembic migration
  - 指令：`alembic revision --autogenerate -m "add session and activity tables"`
- [ ] 1.5 套用 migration：`alembic upgrade head`
- [ ] 1.6 驗證資料表已正確建立（檢查 PostgreSQL）

### Task 2: Core Security 增強 - JWT JTI (AC: 1, 2)
- [ ] 2.1 修改 `backend/app/core/security.py`
  - `create_access_token()` 增加 JTI 生成（使用 uuid.uuid4()）
  - 修改回傳值為 `tuple[str, str]`（token 和 jti）
  - 在 token payload 中加入 `"jti": jti`
- [ ] 2.2 修改 `get_current_user()` 函數
  - 提取 token payload 中的 `jti`
  - 驗證 JTI 是否存在
  - 調用 `SessionService.is_session_valid()` 驗證 Session
  - 調用 `SessionService.update_last_active()` 更新活動時間
  - 若 Session 無效，拋出 401 異常
- [ ] 2.3 新增 `extract_request_metadata(request: Request)` 輔助函數
  - 提取 User-Agent
  - 提取真實 IP（考慮 X-Forwarded-For）

### Task 3: Session Service 實作 (AC: 1, 2)
- [ ] 3.1 創建 `backend/app/services/session_service.py`
- [ ] 3.2 實作 `create_session()` 方法
  - 參數：session, user_id, jti, expires_at, device_info, ip_address
  - 建立新的 LoginSession 記錄
- [ ] 3.3 實作 `get_user_sessions()` 方法
  - 參數：session, user_id
  - 返回用戶所有活躍且未過期的會話
  - 按 `last_active_time` 降序排列
- [ ] 3.4 實作 `revoke_session()` 方法
  - 參數：session, user_id, session_id (JTI)
  - 驗證 Session 屬於該用戶
  - 設定 `is_active=False`
- [ ] 3.5 實作 `revoke_other_sessions()` 方法
  - 參數：session, user_id, current_jti
  - 撤銷用戶所有 Session（除了 current_jti）
- [ ] 3.6 實作 `is_session_valid()` 方法
  - 參數：session, jti
  - 檢查 Session 是否存在、is_active=True、且未過期
- [ ] 3.7 實作 `update_last_active()` 方法
  - 參數：session, jti
  - 更新 Session 的 `last_active_time`

### Task 4: Activity Service 實作 (AC: 3, 4)
- [ ] 4.1 創建 `backend/app/services/activity_service.py`
- [ ] 4.2 實作 `log_activity()` 方法
  - 參數：session, user_id, activity_type, description, ip_address, user_agent, metadata
  - 建立新的 ActivityLog 記錄
- [ ] 4.3 實作 `get_user_activities()` 方法
  - 參數：session, user_id, limit, offset, activity_type (optional)
  - 返回用戶活動記錄（分頁）
  - 按 `timestamp` 降序排列
  - 支援 activity_type 過濾

### Task 5: Auth Endpoints 增強 (AC: 1, 3)
- [ ] 5.1 修改 `backend/app/api/endpoints/auth.py`
  - 修改 `login()` 端點：
    - 調用修改後的 `create_access_token()`（接收 token 和 jti）
    - 建立 LoginSession 記錄（調用 SessionService）
    - 記錄 ActivityLog: "login"（調用 ActivityService）
    - 提取 Request metadata（device_info, ip_address）
  - 修改 `google_login()` 端點：
    - 同樣的增強邏輯（Session + ActivityLog）

### Task 6: Sessions API Endpoints (AC: 1, 2)
- [ ] 6.1 創建 `backend/app/api/endpoints/sessions.py`
- [ ] 6.2 實作 `GET /me/sessions` 端點
  - 使用 `Depends(get_current_user)` 認證守衛
  - 調用 `SessionService.get_user_sessions()`
  - 返回 `List[SessionRead]`
- [ ] 6.3 實作 `DELETE /me/sessions/{session_id}` 端點
  - 使用 `Depends(get_current_user)` 認證守衛
  - 調用 `SessionService.revoke_session()`
  - 記錄 ActivityLog: "session_revoked"
  - 返回成功訊息
- [ ] 6.4 實作 `DELETE /me/sessions` 端點（撤銷所有其他會話）
  - 使用 `Depends(get_current_user)` 認證守衛
  - 從 current_user payload 取得當前 JTI
  - 調用 `SessionService.revoke_other_sessions()`
  - 記錄 ActivityLog: "logout"
  - 返回成功訊息
- [ ] 6.5 註冊 sessions router 到 `backend/app/api/api.py`
  - `api_router.include_router(sessions.router, prefix="/users", tags=["sessions"])`

### Task 7: Activities API Endpoint (AC: 4)
- [ ] 7.1 在 `backend/app/api/endpoints/sessions.py` 中新增活動端點
  - 或創建獨立的 `activities.py` 檔案（視複雜度決定）
- [ ] 7.2 實作 `GET /me/activities` 端點
  - 使用 `Depends(get_current_user)` 認證守衛
  - 接收查詢參數：limit (int, default=50), offset (int, default=0), activity_type (optional str)
  - 調用 `ActivityService.get_user_activities()`
  - 返回 `List[ActivityLogRead]`

### Task 8: 單元測試 - Services (AC: All)
- [ ] 8.1 創建 `backend/tests/unit/test_session_service.py`
  - 測試 `create_session()`
  - 測試 `get_user_sessions()`（包含過濾邏輯）
  - 測試 `revoke_session()`（包含權限驗證）
  - 測試 `revoke_other_sessions()`
  - 測試 `is_session_valid()`（有效/無效/過期情境）
  - 測試 `update_last_active()`
- [ ] 8.2 創建 `backend/tests/unit/test_activity_service.py`
  - 測試 `log_activity()`
  - 測試 `get_user_activities()`（分頁和過濾）
- [ ] 8.3 創建 `backend/tests/unit/test_security_jti.py`
  - 測試 `create_access_token()` 返回 JTI
  - 測試 JTI 為有效 UUID 格式
  - 測試 token payload 包含 "jti" claim
  - 測試 `decode_access_token()` 提取 JTI

### Task 9: 整合測試 - API Endpoints (AC: All)
- [ ] 9.1 在 `backend/tests/conftest.py` 新增 fixture
  - `authenticated_user_with_jti` - 返回 user, token, jti
- [ ] 9.2 創建 `backend/tests/integration/test_sessions_api.py`
  - 測試 GET /api/users/me/sessions（認證 ✓ / 未認證 ✗）
  - 測試 DELETE /api/users/me/sessions/{session_id}（成功撤銷）
  - 測試 DELETE /api/users/me/sessions/{session_id}（嘗試撤銷其他用戶會話 - 403）
  - 測試 DELETE /api/users/me/sessions（撤銷所有其他會話）
  - 測試撤銷後 token 無法使用（401）
- [ ] 9.3 創建 `backend/tests/integration/test_activities_api.py`
  - 測試 GET /api/users/me/activities（認證 ✓ / 未認證 ✗）
  - 測試分頁參數（limit, offset）
  - 測試過濾參數（activity_type）
  - 測試排序（最新的在前）
- [ ] 9.4 創建 `backend/tests/integration/test_auth_enhanced.py`
  - 測試 POST /api/auth/login 建立 Session 記錄
  - 測試 POST /api/auth/login 記錄 ActivityLog
  - 測試 token 包含 JTI
  - 測試多次登入建立多個 Session
  - 測試 remember_me 影響 Session expires_at
- [ ] 9.5 執行測試並確保通過：`pytest backend/tests/`
- [ ] 9.6 檢查測試覆蓋率：`pytest --cov=app backend/tests/`

### Task 10: API 驗證與文件 (AC: All)
- [ ] 10.1 啟動開發伺服器測試所有新端點
- [ ] 10.2 使用 Swagger UI (`/docs`) 驗證 API 文件
  - 確認所有端點出現在文件中
  - 確認 request/response schemas 正確
- [ ] 10.3 使用 curl 或 Postman 手動測試端點
  - 測試登入後查看會話列表
  - 測試撤銷會話功能
  - 測試查看活動記錄
  - 驗證撤銷後 token 無法使用
- [ ] 10.4 驗證資料庫記錄正確性
  - 檢查 LoginSession 表記錄
  - 檢查 ActivityLog 表記錄

### Task 11: 程式碼審查與優化 (AC: All)
- [ ] 11.1 審查所有新增程式碼的命名和文件字串
- [ ] 11.2 確認所有 Service 方法有完整的 docstring
- [ ] 11.3 確認錯誤處理完善（HTTPException with 正確 status code）
- [ ] 11.4 確認資料隔離邏輯正確（用戶只能存取自己的資料）
- [ ] 11.5 標記未來優化點（TODO 註解）：
  - Redis 快取 Session 狀態
  - 定期清理過期 Session
  - Rate Limiting for Session endpoints
  - 異常登入偵測（Epic 4）

### Task 12: QA Agent Review (由 QA Agent 處理)
- [ ] 12.1 執行完整的 QA checklist
- [ ] 12.2 驗收所有 AC
- [ ] 12.3 檢查程式碼品質和安全性
- [ ] 12.4 確認測試覆蓋率達標

---

## Testing

### Test File Locations
[Source: docs/architecture/2-後端架構詳細設計-sqlmodel.md#FastAPI-專案結構]

**單元測試：**
- `backend/tests/unit/test_session_service.py` - SessionService 測試
- `backend/tests/unit/test_activity_service.py` - ActivityService 測試
- `backend/tests/unit/test_security_jti.py` - JWT JTI 測試

**整合測試：**
- `backend/tests/integration/test_sessions_api.py` - Sessions API 測試
- `backend/tests/integration/test_activities_api.py` - Activities API 測試
- `backend/tests/integration/test_auth_enhanced.py` - Enhanced Login 測試

### Testing Standards
- 使用 `pytest` 作為測試框架
- 使用 `pytest-cov` 測量測試覆蓋率
- 參考 `backend/tests/conftest.py` 的測試配置
- 目標覆蓋率：80% (依據 NFR1.6)

### Testing Frameworks and Patterns
- 整合測試使用 FastAPI TestClient
- 資料庫測試使用 SQLite in-memory 或獨立測試資料庫
- 新增 `authenticated_user_with_jti` fixture 用於 Session 測試
- 參考 Story 1.5 的測試模式（`backend/tests/integration/test_dashboard_api.py`）

### Specific Testing Requirements for This Story
1. **Session 生命週期測試**：建立、查詢、撤銷、驗證
2. **JTI 唯一性測試**：確保每次登入生成不同 JTI
3. **權限隔離測試**：用戶不能撤銷其他用戶的 Session
4. **Token 撤銷測試**：撤銷後的 token 應返回 401
5. **Activity 記錄測試**：驗證所有重要操作都有記錄

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-22 | 1.0 | Initial story creation for Session and Security Management | Scrum Master (Bob) |

---

## Dev Agent Record

### Agent Model Used
(To be filled by Dev Agent)

### Debug Log References
(To be filled by Dev Agent)

### Completion Notes
(To be filled by Dev Agent)

### File List
(To be filled by Dev Agent)

---

## QA Results
(To be filled by QA Agent)

